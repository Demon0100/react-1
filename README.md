# 202330215 송승헌

# 2025.05.08 9주차

#### React로 사고하기
  React로 사용자 인터페이스를 빌드할 때, 먼저 이를 컴포넌트라는 조각으로 나눕니다.
  그리고 각 컴포넌트의 다양한 시각적 상태들을 정의합니다.
  마지막으로 컴포넌트들을 연결하여 데이터가 그 사이를 흘러가게 합니다.

#### Step 1 : UI를 컴포넌트 계층으로 쪼개기
* 어떤 배경을 가지고 있냐에 따라, 디자인을 컴포넌트로 나누는 방법에 대한 관점이 달라질 수 있다.
* Programming : 새로운 함수나 객체를 만드는 방식과 같은 방법
  * 이 중 단일책임 원칙을 반영하고자 한다면 컴포넌트 이상적으로는 한번에 한 가지 일만 해야 합니다.
  * 만약 컴포넌트가 점점 커진다면 작은 하위 컴포넌트로 쪼개져야 한다.
* CSS : 클래스 선택자를 무엇으로 만들지 생각해본다.(실제 컴포넌트들은 약간 좀 더 세분되어 있다.)
* Design : 디자인 계층을 어떤 식으로 구성할 지 생각해 본다.

* FilterableProductTable(회색) : 예시 전체를 포괄합니다.
* SearchBar(파란색) : 사용자의 입력을 받습니다.
* ProductTable(라벤더색) : 데이터 리스트를 보여주고, 사용자의 입력을 기반으로 필터링합니다.
* ProductCategoryRow(초록색) : 각 카테고리의 헤더를 보여줍니다.
* ProductRow(노란색) : 각각의 제품에 해당하는 행을 보여줍니다.

#### Step 2 : React로 정적인 버전 구현하기.
* 가장 쉬운 방법은 상호작용 기능은 추가하지 않고, 데이터 모델로부터 UI를 렌더링하는 버전을 만드는 것이다.
* 대체로 먼저 정적인 버전을 만들고 상호작용 기능을 추가하는게 더쉽다.
* 정적 버전을 만드는것은 많은 타이핑이 필요하지만, 생각할 것은 적다.
* 반대로 상호작용 기능을 추가하는건 많은 생각이 필요하지만, 타이핑은 그리 많이 필요하지 않다.
* 데이터 모델을 렌더링하는 앱의 정적인 버전을 만들기 위해서는
  * 다른 컴포넌트를 재사용하고,
  * props를 이용하여 데이터를 넘겨주는 컴포넌트를 구현하는 것이 좋다.
* props는 부모가 자식에게 데이터를 넘겨줄 때 사용할 수 있는 방법이다.

#### 

# 2025.04.18 보강주차

#### 과거 움직임 보여주기
* <.button>과 같은 React 엘리먼트는 일반 JavaScript 객체이므로 애플리케이션에서 전달할 수 있다.
* React에서 여러 엘리먼트를 렌더링하려면 React 엘리먼트 배열을 사용할 수 있다.
* JavaScript에서 한 배열을 다른 배열로 변환하려면 배열 map 메서드를 사용하면 된다.

#### map의 기본 구문
* map의 기본은 map(callbackFn)혹은 map(callbackFn, thisArg) 입니다.
* thisArg는 내부에서 this로 사용할 값을 지정하는데 화살표 함수에서는 생략됩니다.
* 따라서 callbackFn만 사용하고, 화살표 함수가 callback함수를 대신 할수도 있다.
* squares, move는 화살표 함수의 매개변수이다.

#### map함수의 사용
* 정리하자면
  - 원본 배열(history): map이 호출된 원본 배열.
  - 원본 배열의 인덱스(move): 현재 순환 중인 원본 배열 요소의 인덱스.
  - 요소 값 (squares):현재 순회 중인 요소 배열의 값.
* history.map((squares, move) => {...})는 다음과 같이 동작한다.
  - 첫번째 호출: squares = [null, null, null, null, null, null, null, null, null], move = 0
  - 두번째 호출: squares = ['X', null, null, null, null, null, null, null, null], move = 1
  - 세번째 호출: squares = ['X', 'O', null, null, null, null, null, null, null], move = 2
* 각각의 history 요소에 대한 { }의 실행문(후작업) 실행합니다.
* moves 객체에 저장합니다.
* 최종출력에 사용합니다.

#### Key 선택하기
* 리스트를 렌더링할 때 React는 렌더링 된 각 리스트 항목에 대한 몇 가지 정보를 저장합니다.
* 리스트를 업데이트 할 때 React는 무엇이 변경되었는지 확인해야 합니다.
* 리스트의 항목은 추가, 제거, 재정렬 또는 업데이트될 수 있습니다.
* key는 React에서 특별히 미리 지정된 프로퍼티입니다.
* 엘리먼트가 생성되면 React는 Key 프로퍼티를 추출하여 반환되는 엘리먼트에 직접 key를 저장한다.
* key가 props로 전달되는 것처럼 보일 수 있지만, React는 자동으로 key를 사용해 업데이트할 컴포넌트를 결정합니다.
* 부모가 지정한 key가 무엇인지 컴포넌트는 알 수 없습니다.
* 동적인 리스트를 만들 때마다 적절한 key를 할당하는 것을 강력하게 추천합니다.
* 적절한 key가 없는 경우 데이터의 재구성을 고려해 보세요.
* key가 지정되지 않은 경우, React는 경고를 표시, 배열의 인덱스를 기본 key로 사용.
* 배열 인덱스를 key로 사용하면, 리스트 항목의 순서를 바꾸거나 항목을 추가/제거할 때 문제가 발생.
* 명시적으로 key={i}를 전달하면 경고는 사라지지만, 배열의 인덱스를 사용할 때와 같은 문제가 발생하므로 대부분은 추천하지 않습니다.


#### 

# 2025.04.17 7주차

#### state 끌어올리기
* DOM <.button> 엘리먼트의 onClick 어트리뷰트(속성)은 빌트인 컴포넌트이기 때문에 React에서 특별한 의미를 가짐.
* 사용자 정의 컴포넌트, 예로 Square의 경우 이름은 사용자가 원하는 대로 지을 수 있습니다.
* Square의 onSquareClick prop나 Board의 handleClick 함수에 어떠한 이름을 붙여도 코드는 동일하게 작동.
* React에서는 주로 이벤트를 나타내는 prop에는 onSomething과 같은 이름을 사용하고, 이벤트를 처리하는 함수를 정의 할 때는 handleSomething과 같은 이름을 사용합니다.

#### 불변성이 왜 중요할까요
* 최종 결과는 같지만, 원본 데이터를 직접 변형하지 않음으로서 몇가지 이점을 얻을 수 있습니다.

1. 불변성을 사용하면 복잡한 기능을 훨 쉽게 구현할 수 있습니다.
  * 직접적인 데이터 변경을 피하면 이전 버전의 데이터를 그대로 유지하여 나중에 재사용( 또는 초기화) 할 수 있습니다.
2. 불변성을 사용하는 것의 또 다른 장점들이 있다.
  * 기본적으로 부모 컴포넌트의 state가 변경되면 모든 자식 컴포넌트가 자동으로 다시 렌더링 됩니다.
  * 여기에는 변경 사항이 없는 자식 컴포넌트도 포함됩니다.
  * 리렌더링 자체가 사용자에게 보이는 것은 아니지만, 성능상의 이유로 트리의 영향을 받지 않는 부분의 리렌더링을 피하는것이 좋습니다.
  * 불변성을 사용하면 컴포넌트가 데이터의 변경여부를 저렴한 비용으로 판단할 수 있습니다.

### return의 의미
* JavaScript에서 return값이 없는 return;은 함수를 즉시 종료하라는 의미.
  * 이때 값을 반환하지 않으면 자동으로 undefined를 반한함.
* squares[i]가 이미 값이 있다면(누군가 이미 둔 곳이라면) 그자리에 다시 둘 수 없으니 아무일도 하지 말고 함수를 끝내는 것입니다.


# 2025.04.10 6주차

#### prop를 통해 데이터 전달하기
1. React의 component architecture를 사용해서 재사용할 수 있는 component를 만들어서 지저분하고 중복된 코드 삭제
2. Board component를 만들고, square component의 내용을 복사한다.
3. square component의 button을 하나만 남기고 모두 삭제한다
4. Board component의 button을 square component로 교체한다.
5. App에서 호출하는 component를 square에서 Board로 바꿔준다.

* 여기까지 할 시에 component는 깔끔하게 정리 되었지만, 숫자출력이 1만 나오게 된다.
* 이 문제를 해결하기 위해 props를 사용하여 각 사각형이 가져야 할 값을 부모 component(Board)에서 자식 component(square)로 전달한다.
* component를 호출하는 쪽이 부모 component이다.

### state 끌어올리기
* 여러 자식 컴포넌트에서 데이터를 수집하거나 두 자식 컴포넌트가 서로 통신하도록 하려면, 부모 컴포넌트에서 공유 state를 선언해야함.
* 부모 컴포넌트는 props를 통해 해당 state를 자식 컴포넌트에 전달 할 수 있다.
* 이러면 자식 컴포넌트가 서로 동기화 되고, 부모 컴포넌트와도 동기화 되도록 할 수 있다.
* React 컴포넌트를 리팩토링할 때 부모 컴포넌트로 state를 끌어올리는 건 많이 사용되는 방법이다.

### 


# 2025.04.03 5주차

### Hook 사용하기
* use로 사직하는 함수가 Hook이다
* useState는 React에서 제공하는 내장 Hook이다
* Hook은 다른 함수보다 더 제한적이다.
  * component 또는 다른 Hook의 상단에서만 Hook을 호출할 수 있다.
  * 조건이나 반복문에서 useState를 상용하고 싶다면 새 컴포넌트를 추출하여 그곳에 넣어야한다.

#### Hook의 사용규칙
! 왜 이런 규칙이 필요한가? : React의 동작을 예측 가능하고, 안정성을 높이기 위해 필요
1. rendering 순서를 보장하기 위해

  조건문이나 반복문 안에서 Hooks를 사용하면
  매 rendering마다 Hook의 호출 순서가 달라질 수 있기 때문에
  React가 상태를 제대로 추적할 수 없다.

2. 불필요한 사이드 이펙트 방지

  component가 여러번 rendering 될 때마다
  동일한 순서로 Hook이 실행되어야 React가 의도한 동작을 수행할 수 있다.

#### component 간 데이터 공유
- 각 component 객체가 독립적으로 동작함
- component는 하나지만 count 변수도 객체로 여러 개 복사된 것이나 마찬가지이기 때문입니다.

# 2025.03.27 4주차

### Component의 생성 및 nesting(중첩)
#### component는
1. 고유한 로직과 모양을 가진 UI의 일부.
2. 버튼처럼 작을 수도, 전체 페이지처럼 클 수도 있다.
3. 마크업을 반환하는 JavaScript 함수.

#### export default와 export의 차이
* Named Exports
 - 하나의 파일안에 여러개의 component가 있을때 사용.
 - component를 사용하는 쪽에서는 component 정확한 이름을 반드시 명시.
* Default Exports
 - 하나의 파일안에서 하나의 component만 내보내는 경우 사용.
 - component를 사용하는 쪽에서는 어떤 이름을 사용해도 무관.

### JSX로 마크업 작성하기
앞에서 작성한 코드의 마크업 문법 : JSX
#### JSX
* JSX는 HTML보다 더욱 엄격한 문법을 적용
* JSX에선 싱글 태그라도 태그를 닫아야함 ex: < />
* React에선 여러개의 component를 JSX태그로 반환할 수 있다.
  다만 여러개의 component를 wrapping 해줘야 한다.

#### 스타일 추가하기
* React에서는 className으로 CSS클래스를 지정한다.
* className은 HTML의 class 속성과 동일한 방식으로 동작한다.
* React는 CSS파일을 추가하는 방법을 규정하진 않는다.
  -> 정적 페이지 작성때와 동일한 방법 지원
* 가장 간단한 방법은 HTML에 link태그 추가하는것.

#### 데이터 표시하기
  JSX를 사용하면 자바스크립트에 마크업을 넣을 수 있다.
  JSX 코드 내에서 JavaScript로 탈출하여 변수나 표현식을 사용하는 것이다.
  {}중괄호를 사용해서 변수나 표현식을 사용자에게 표시하도록 하는것 이다.
* 이 방법을 "Escape Back"이라고 한다.

# 2025.03.20 3주차

### React Project의 구조 및 역할2
* node_modules/ : 초기 node module 및 새로 설피하는 패키지가 저장됨
* public/ : 정적 파일을 저장하는 디렉토리
* src/ : React 프로젝트의 주요 코드가 위치하는 디렉토리
  * src/App.js : 메인 컴포넌트로 필요한 서브 컴포넌트를 모아서 관리
  * src/App.css : App.js에 적용되는 스타일을 정의하는 스타일 파일
  * src/index.js : React 앱의 진입 점으로 최종 렌더링의 되는 곳
  * src/index.css : 전역 스타일을 정의하는 스타일 파일

### 의존성 관리와 package.json
#### 의존성을 관리하는 이유
* 손쉬운 설치 및 업데이트
* 일관된 개발 환경 유지
* 중복 설치 방지

#### package.json을 유지해야 하는 이유
* 프로젝트의 의존성 정보 제공
* 버전 범위 설정 가능
* 스크립트와 메타데이터 저장
* 새로운 패키지 설치 및 관리

#### React
  React는 라이브러리. 
  컴포넌트를 조합할 수 있도록 돕지만, 라우팅이나 데이터를 가져오는 방법을 규정하지 않음
  React로 완전한 앱을 만드려면 Next.js 또는 Remix같은 풀스택 React 프레임워크를 추천
  React도 하나의 아키텍처

모든 플랫폼에서 최고의 성능을 발휘하는 React
* React를 사용하면 동일한 기술을 사용하여, 웹 앱과 네이티브 앱 모두 구축 가능
* 각 플랫폼의 고유한 강점을 활용하여 모든 플랫폼 잘 어울리는 인터페이스 구현 가능



#### React 컴포넌트
1. React 컴포넌트는 데이터를 받고 화면에 표시할 내용을 반환.
2. 사용자가 입력란에 입력하는 것과 같이 상호작용에 응답하여 새 데이터 전달 가능.
3. React는 새 데이터와 일치하도록 화면을 업데이트함.



# 2025.03.13 2주차

깃허브와 vsCode를 연동하여 커밋하는 방법을 배웠다.

### Node.js란?

#### 장단점
* 장점
> 비동기 논 블로킹 I/O로 높은 성능
  JavaScript 풀스택 개발이 가능
  npm의 방대한 생태계를 활용 가능
  경량 서버 개발에 적합(Express.js)
  실시간 데이터 처리가 강력
* 단점
> CPU 집약적인 작업에 부적합 : 멀티스레딩 성능 부족
  콜백 지공 문제
  보안 취약

### React Project의 구조 및 역할
* public/ : 정적 파일을 저장하는 폴더, 빌드 시 그대로 유지
  * index.html : React 앱이 마운트 되는 HTML파일.
* src/ : React 앱의 주요 코드가 위치하는 폴더
  * App.css : App.js에 적용되는 스타일
  * App.js : 메인 컴포넌트
  * index.css : 전역 스타일
  * index.js : React 앱의 진입점. ReactDOM.createRoot를 사용하여 App.js를 렌더링
* .gitignore : Git에 추가하지 않을 파일 목록을 정의.
* package-lock.json : 설치된 패키지의 정확한 버전이 기록된 파일
* package.json : 프로젝트의 의존성 목록과 실행 스크립트가 포함된 파일.
* README.md : 프로젝트 설명 문서.