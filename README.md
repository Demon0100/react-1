# 202330215 송승헌

# 2025.05.29 12주차

### React 앱 렌더링 전략 요약

## SPA (Single Page Application)

- **SPA**는 단일 HTML 파일로 작동하며, 사용자의 조작에 따라 **JavaScript로 페이지 일부만 업데이트**함.
- 초기 로딩이 느릴 수 있음.
- 대부분의 빌드 도구에서 **기본 설정**으로 사용됨.

## 렌더링 방식 비교

### 1. SSR (Server Side Rendering)

- 서버에서 HTML을 완전히 렌더링하여 클라이언트로 전송.
- **성능은 향상**되지만, 설정 및 유지 관리가 복잡함.
- 스트리밍 기능까지 추가되면 SSR 설정이 매우 복잡해짐.
- 참고: `Vite의 SSR 가이드`

### 2. SSG (Static Site Generation)

- **빌드 시 HTML 파일을 미리 생성**함.
- SSR보다 설정 및 유지가 간편함.
- **성능은 좋지만 유연성은 떨어짐**.
- 참고: `Vite의 SSG 가이드`

### 3. RSC (React Server Components)

- 서버 전용 컴포넌트를 통해 **빌드 타임, 서버 전용, 인터랙티브 컴포넌트 분리** 가능.
- DB 접근 등 서버 자원을 활용 가능.
- 실무에서는 설정/유지에 대한 전문 지식 필요.
- 참고: `Parcel의 RSC 예시`

## 적절한 렌더링 전략 선택 기준

- 프레임워크가 라우터와 통합하여 다양한 렌더링 전략 선택 가능.
- 전체 앱을 다시 작성하지 않고도 다양한 전략 사용 가능.

#### 예시 전략
- 정적 콘텐츠 위주 페이지 → **SSG** 사용 유리
- 사용자 맞춤형 데이터 포함 페이지 → **SSR** 또는 **RSC** 사용 유리

#### 렌더링 성능 지표
-  첫 번째 바이트까지의 시간 (TTFB)
-  첫 번째 콘텐츠 페인트 (FCP)
-  가장 큰 콘텐츠 페인트 (LCP)


## 기존 프로젝트에 React 도입하기

### 방법 1: 특정 경로에 React 앱 전체 연결

1. React 기반 프레임워크(예: **Next.js**, **Gatsby**)로 앱 부분 빌드
2. 프레임워크 설정에서 `/some-app` 경로 지정
3. 해당 경로 요청 시 React 앱으로 처리되도록 **서버 라우팅 설정**

> 참고:  
> - `Next.js → next export` 사용  
> - `Gatsby → 기본 정적 배포`

### 방법 2: 기존 페이지 내 React 컴포넌트 삽입

1. JSX를 사용할 수 있도록 JS 환경 설정
2. `import/export` 구문 사용하여 모듈화
3. `npm`으로 React 설치 후, 원하는 위치에 컴포넌트 렌더링

---

##  주의 사항

- SPA 외 SSR, SSG, RSC는 **설정과 유지에 대한 깊은 이해**가 필요함.
- 스스로 해결이 어렵다면, 해당 기능을 제공하는 **프레임워크 사용 권장**


# 2025.05.22 11주차

새로운 React 앱 만들기  
React로 새로운 앱이나 웹사이트를 만들려면 프레임워크를 사용하는 것이 좋다.  
직접 빌드할 수도 있지만, 배포와 유지보수에 필요한 기능을 모두 포함한 풀스택 프레임워크가 유리하다.

풀스택 프레임워크란  
- 최신 React 기능을 포함하고, React 아키텍처를 최대한 활용  
- 클라이언트 렌더링(SPA), 정적 사이트 생성(SSG), 서버 사이드 렌더링(SSR)을 모두 지원  
- 서버 없이도 CDN, 정적 호스팅으로 배포 가능  
- 나중에 개별 경로에 서버 기능 추가 가능

Next.js  
- Vercel에서 공식 지원  
- Node.js 서버 또는 정적 내보내기 방식으로 배포 가능  
- 클라이언트 전용 앱으로 시작 후 서버 기능 추가 가능  
- 유료 기능은 선택적으로 사용 가능 (opt-in 구조)

React Router v7  
- React에서 가장 널리 사용되는 라우팅 라이브러리  
- Vite와 함께 사용 시 풀스택 프레임워크 구성도 가능  
- Web API 기반, 다양한 플랫폼과 배포 템플릿 지원  
- Shopify에서 유지 및 관리

Expo (네이티브 앱용)  
- Expo는 네이티브 UI를 사용하여 안드로이드, iOS, 웹을 위한 범용 앱을 만들 수 있는 React 프레임워크이다.  
- React Native SDK를 제공하여 네이티브 앱을 쉽게 만들 수 있게 도와준다.  
- Expo는 Expo(the company)에서 유지 관리한다.  
- 앱 빌드는 무료이며, 구글 플레이나 애플 앱스토어에 제출 시 별도의 제한 없이 가능  
- 유료 클라우드 서비스도 선택적으로 제공함

기타 떠오르는 풀스택 React 프레임워크들

TanStack Start (Beta)  
- TanStack Router 기반 풀스택 React 프레임워크  
- Vite, Nitrol과 함께 사용  
- 문서 기반 SSR, 스트리밍, 서버 함수 등 다양한 개발 도구 제공

RedwoodJS  
- 사전 설정된 구성과 패키지를 통해 쉽게 풀스택 앱을 만들 수 있도록 돕는 프레임워크  
- 스타트업 친화적인 개발 환경 제공

Vite

Vite는 현대 웹 프로젝트를 빠르게 시작하고, 가벼운 개발 환경을 제공하는 것을 목표로 하는 빌드 도구이다.

특징  
- 빠른 새로고침과 빠른 빌드 속도  
- JSX, Babel, SWC 및 기타 외부 기능을 지원하는 다양한 플러그인 생태계  
- 설정이 단순하고 합리적인 기본 구성을 제공

사용 예  
- React 플러그인 또는 React SWC 플러그인과 함께 사용 가능  
- React SSR 예제 프로젝트를 통해 시작할 수 있다  
- React Router, Next.js 등의 프레임워크에서도 Vite를 빌드 도구로 사용하고 있다

Vite 프로젝트 생성 명령어  
npm create vite@latest my-app -- --template react

Parcel

- Parcel은 개발 초기 단계에서 대규모 애플리케이션으로의 확장을 고려한 빌드 도구이다.
- 설정이 거의 필요 없고, 빠른 새로고침, JSX, TypeScript, Flow, 스타일링 등을 기본적으로 지원한다.
- React 프로젝트에 빠르게 적용 가능하며, 설정 없이도 즉시 개발 시작 가능하다.

Rsbuild

- Rsbuild는 Rspack 기반의 React 전용 빌드 도구이다.
- 성능이 조정된 설정과 빠른 실행 속도, 최적화된 빌드 환경을 제공한다.
- JSX, TypeScript, 스타일링 등을 기본 지원하며 빠른 새로고침도 가능하다.

# 2025.05.08 9주차

React로 사고하기  
UI를 설계할 때는 먼저 화면을 컴포넌트 계층으로 나눈다.  
그 후 각 컴포넌트의 상태를 정의하고, 데이터 흐름을 따라 연결한다.

Step 1: 컴포넌트 계층으로 나누기  
- 단일 책임 원칙에 따라 컴포넌트는 한 가지 기능만 담당해야 함  
- 컴포넌트가 커진다면 더 작은 하위 컴포넌트로 분리  
- 설계 관점은 프로그래밍/디자인/CSS 관점마다 다를 수 있음

예시 구조  
- FilterableProductTable: 전체를 포괄  
- SearchBar: 사용자 입력  
- ProductTable: 제품 목록 + 필터링  
- ProductCategoryRow: 카테고리 제목  
- ProductRow: 실제 제품 행

Step 2: 정적인 버전 먼저 만들기  
- 상호작용 없이 데이터 기반으로 UI만 렌더링  
- 타이핑은 많지만, 로직 고민은 적어 개발 속도가 빠름  
- 이후 state와 이벤트를 추가  
- props를 통해 부모 → 자식으로 데이터 전달

# 2025.04.18 보강주차

React에서 리스트 렌더링과 Key 사용

map 함수  
- 배열을 다른 배열로 변환할 때 사용  
- 예: history.map((squares, move) => {...})  
- squares: 현재 요소  
- move: 현재 인덱스  
- 각 요소에 대해 JSX를 반환하여 리스트 생성

Key의 역할  
- React는 리스트 항목의 변경 여부를 확인하기 위해 key를 사용  
- key가 없으면 경고 발생, 배열 인덱스를 기본 key로 사용하지만 비권장  
- 적절한 고유 key를 사용해야 성능 최적화와 정확한 렌더링 가능

리스트 렌더링 시 주의사항  
- key는 React가 비교/업데이트할 때 사용  
- 컴포넌트 내부에서는 key를 알 수 없음  
- 동적인 리스트일수록 key는 필수

# 2025.04.17 7주차

state 끌어올리기  
- 여러 자식이 동일한 데이터를 필요로 할 때, 부모 컴포넌트로 state를 끌어올린다  
- 부모 → 자식으로 props 전달, 자식에서 발생한 이벤트는 부모에서 처리

이벤트 핸들링 명명법  
- prop: onClick, onChange 등  
- 함수: handleClick, handleChange 등으로 작성하는 것이 일반적

불변성 유지의 장점  
1. 이전 상태를 보존 가능  
2. 성능 최적화: 변경되지 않은 컴포넌트는 리렌더링 생략 가능

return의 의미  
- return; → 함수 종료  
- 조건문에서 사용해 특정 상황엔 실행 중단 가능  
- 예: 이미 클릭된 칸이면 return으로 종료

# 2025.04.10 6주차

props로 데이터 전달  
- 컴포넌트를 깔끔하게 분리한 후, 부모가 자식에게 데이터를 전달할 때 props 사용  
- 자식은 props를 통해 전달받은 값을 렌더링

state 끌어올리기  
- 형제 컴포넌트 간 상태 공유를 위해 부모에서 상태를 관리  
- 자식 컴포넌트는 props를 통해 전달받아 동작

# 2025.04.03 5주차

Hook 사용하기  
- useState 등 use로 시작하는 함수는 Hook  
- 컴포넌트 최상단에서만 호출해야 하며, 조건문/반복문 안에서는 사용 불가

Hook 사용 규칙의 이유  
1. Hook 호출 순서를 React가 기억해야 상태를 올바르게 유지할 수 있음  
2. 불필요한 side effect를 방지

컴포넌트 간 상태 공유  
- 동일한 컴포넌트를 여러 번 렌더링해도 각각의 state는 독립적이다

# 2025.03.27 4주차

Component 생성 및 중첩  
- Component: UI의 한 조각  
- JavaScript 함수로 작성  
- 작은 단위부터 큰 구조까지 설계 가능

JSX 문법  
- HTML과 유사한 문법이지만 더 엄격함  
- 태그는 반드시 닫아야 하고, 여러 요소는 하나의 부모 요소로 감싸야 함  
- class는 className으로 사용

스타일 적용  
- CSS 파일 import 또는 HTML의 link 태그 사용  
- className으로 스타일 지정

데이터 표현  
- JSX 내에서 중괄호 {} 사용해 변수나 표현식을 출력

# 2025.03.20 3주차

React 프로젝트 구조  
- public/: 정적 파일 저장, index.html 포함  
- src/: 실제 코드  
  - App.js: 메인 컴포넌트  
  - index.js: 진입점  
- package.json: 의존성, 스크립트, 프로젝트 메타정보 포함

의존성 관리  
- 버전 관리, 환경 통일, 설치 간소화를 위해 필요  
- package.json과 package-lock.json이 함께 사용됨

# 2025.03.13 2주차

Node.js란?  
- JavaScript로 서버를 개발할 수 있게 해주는 런타임

장점  
- 비동기 논블로킹 처리  
- npm 생태계  
- 프론트와 백엔드를 같은 언어로 개발  
- 실시간 처리에 적합

단점  
- CPU 집약 작업엔 부적합  
- 콜백 지옥 문제  
- 보안 취약성

React 개요  
- UI 구축을 위한 JavaScript 라이브러리  
- 컴포넌트를 조합하여 앱을 구성  
- 라우팅이나 데이터 관리는 별도 도구로 해결

컴포넌트 특징  
- 데이터를 받아 화면을 구성  
- 사용자 입력 등 상호작용에 반응  
- 새로운 데이터가 전달되면 자동으로 화면 갱신
